# 범위와 구간 문제는 정렬부터

## 핵심 인사이트

**"범위", "구간", "시간"이 나오면 → 일단 정렬부터 하자!**

범위/구간 관련 문제는 정렬 후 그리디 알고리즘으로 풀리는 경우가 많다.

## 왜 정렬이 효과적인가?

1. **국소적 최적 선택 = 전역 최적해**
   - 정렬된 상태에서는 앞에서부터 탐욕적으로 선택해도 최적해 보장
   - 예: "가장 빨리 끝나는 회의부터 선택"

2. **명확한 선택 기준 생성**
   - 정렬 전: 어떤 것을 먼저 선택해야 할지 불명확
   - 정렬 후: 순서대로 선택하면 됨

3. **시간 복잡도 효율**
   - 정렬: O(N log N)
   - 이후 탐색: O(N)
   - 총 O(N log N) - 매우 효율적!

## 대표 문제 유형

### 1. 회의실 배정
- **정렬 기준**: 끝나는 시간 우선, 같으면 시작 시간
- **선택 기준**: 이전 회의 끝 시간 ≤ 현재 회의 시작 시간
```python
arr.sort(key=lambda x: (x[1], x[0]))  # (끝, 시작) 기준 정렬
pre_end = -1
for start, end in arr:
    if pre_end <= start:
        pre_end = end
        cnt += 1
```

### 2. ATM 대기 시간 최소화
- **정렬 기준**: 소요 시간 오름차순
- **선택 기준**: 짧은 시간부터 처리

### 3. 로프 문제
- **정렬 기준**: 무게 오름차순
- **선택 기준**: k개 사용 시 최소 무게 × k

### 4. 선 긋기
- **정렬 기준**: 시작 좌표 또는 끝 좌표
- **선택 기준**: 겹치는 구간 병합

### 5. 과제 마감일
- **정렬 기준**: 마감일 또는 점수
- **선택 기준**: 마감일 내 최대 점수

## Python 정렬 팁

### 기본 정렬
```python
arr.sort()  # 오름차순
arr.sort(reverse=True)  # 내림차순
```

### lambda로 정렬 기준 지정
```python
# 끝나는 시간 기준
arr.sort(key=lambda x: x[1])

# 끝나는 시간 우선, 같으면 시작 시간
arr.sort(key=lambda x: (x[1], x[0]))

# 첫번째 값 내림차순
arr.sort(key=lambda x: -x[0])

# 첫번째 오름차순, 두번째 내림차순
arr.sort(key=lambda x: (x[0], -x[1]))
```

### 여러 조건 정렬 예시
```python
# 학생 정보: (이름, 점수, 나이)
students.sort(key=lambda x: (-x[1], x[2], x[0]))
# 점수 높은 순 → 나이 낮은 순 → 이름 사전순
```

## 문제 풀이 전략

1. **문제에서 "범위", "구간", "시간" 키워드 확인**
2. **정렬 기준 정하기**
   - 시작점? 끝점? 둘 다?
   - 오름차순? 내림차순?
3. **그리디 선택 기준 정하기**
   - 어떤 조건일 때 선택할 것인가?
   - 이전 선택이 다음 선택에 어떤 영향을 주는가?
4. **구현**
   - 정렬 → 순회하며 조건 체크 → 카운트/합산

## 주의사항

1. **끝나는 시간이 같을 때**를 고려하라
   - `(끝, 시작)` 순으로 정렬하면 안전

2. **경계 조건 확인**
   - `끝 시간 = 다음 시작 시간` 허용? → `<=` or `<`
   - 문제에서 "같은 시간에 시작 가능" 확인

3. **정렬 후에도 완전 탐색 필요한 경우**
   - 정렬이 답은 아님, 전처리일 뿐
   - DP, 이분 탐색 등과 결합되는 경우도 있음

## 실전 적용

범위/구간 문제를 만나면:
1. 일단 정렬부터 시도
2. 안 되면 다른 방법 고민
3. 대부분은 정렬 + 그리디로 해결됨!

**"범위를 어쩌고 저쩌고 하는 놈들은 다 정렬부터 갈겨버려라!"** 💪
