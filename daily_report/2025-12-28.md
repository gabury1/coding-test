# 2025-12-28 코딩테스트 문제 풀이

## 해결한 문제

### [1931] 회의실 배정 ✅
- **알고리즘**: 그리디 (Greedy) + 정렬
- **핵심 개념**:
  - 끝나는 시간 기준으로 정렬 후 탐욕적 선택
  - 끝나는 시간이 같으면 시작 시간 기준 정렬
  - 이전 회의 끝나는 시간만 기억하면 됨
- **구현 포인트**:
  - `arr.sort(key=lambda x: (x[1], x[0]))` - 끝나는 시간 우선, 같으면 시작 시간
  - `pre_end <= start` - 끝나는 시간 = 다음 시작 시간 허용 (`<=` 사용)
  - 마지막 회의의 끝나는 시간만 추적하면 충분
- **시행착오**:
  - ❌ 처음에 백트래킹(DFS)으로 접근 → O(2^N) 시간 복잡도
  - ✅ 정렬 + 그리디로 변경 → O(N log N)
  - ❌ `sort(lambda a, b: b)` - lambda 사용법 오류
  - ✅ `sort(key=lambda x: x[1])` - key 파라미터로 정렬 기준 지정

### [10026] 적록색약 ✅
- **알고리즘**: DFS (깊이 우선 탐색)
- **핵심 개념**:
  - 일반인과 적록색약 두 경우를 동시에 처리
  - 파란색(B)는 두 경우 모두 동일하게 구분
  - 빨강(R)과 초록(G)은 적록색약에게 같은 색
- **구현 포인트**:
  - `sys.setrecursionlimit()` 설정 필요 (N=100이면 10000 정도면 충분)
  - 일반인용 DFS + 적록색약용 DFS 분리
  - B는 한 번만 카운트, R/G는 각각 처리
- **개선점**:
  - BFS로 구현하면 재귀 깊이 걱정 없음
  - 그리드를 2개 만들어 분리하면 더 명확함
  ```python
  special_grid = [row.replace('G', 'R') for row in grid]
  ```

### [14940] 쉬운 최단거리 ✅
- **알고리즘**: BFS (너비 우선 탐색)
- **핵심 개념**:
  - 목표 지점(2)에서 시작하여 모든 칸까지의 최단 거리 계산
  - 갈 수 없는 곳(0)은 0으로, 도달 불가능한 곳은 -1로 표시
- **구현 포인트**:
  - 시작점(2)을 큐에 넣고 거리 0으로 초기화
  - 방문 체크 배열로 중복 방문 방지
  - 원래 0인 곳은 결과도 0으로 설정
- **버그 & 해결**:
  - ❌ `if not (범위체크) and 조건` → 범위 밖인데 배열 접근
  - ✅ `if not (범위체크): continue` → 범위 체크 먼저 분리
  - ❌ `result_mtx = lev` → 전체 행렬을 숫자로 덮어씀
  - ✅ `result_mtx[ny][nx] = lev + 1` → 인덱스 추가
  - ❌ `or` 연산자로 범위 체크와 다른 조건 결합
  - ✅ 범위 체크를 먼저 하고, 범위 안일 때만 다음 조건 체크

## 새로운 인사이트

### 1. **범위/구간 문제는 정렬부터!** ⭐
- "범위", "구간", "시간" 키워드가 나오면 → **정렬부터 시도**
- 정렬 후 그리디 알고리즘이 대부분 통함
- **왜 효과적인가?**
  - 국소적 최적 선택 = 전역 최적해
  - 명확한 선택 기준 생성
  - O(N log N) 정렬 + O(N) 탐색 = 효율적
- **대표 문제 유형**:
  - 회의실 배정, ATM 대기 시간, 로프, 선 긋기, 과제 마감일 등
- **정렬 팁**:
  ```python
  # 끝나는 시간 우선, 같으면 시작 시간
  arr.sort(key=lambda x: (x[1], x[0]))

  # 첫번째 오름차순, 두번째 내림차순
  arr.sort(key=lambda x: (x[0], -x[1]))
  ```
- 📝 상세 내용은 [`insight/범위와 구간 문제는 정렬부터.md`](../insight/범위와%20구간%20문제는%20정렬부터.md) 참고

### 2. **어려운 문제일수록 로직을 단순하게!**
- 복잡한 로직 = 디버깅 지옥 + 엣지 케이스 폭증
- 단순한 로직 = 버그 적음 + 실수 감소 + 빠른 구현
- **실전 전략**:
  ```python
  # ❌ 복잡한 접근
  if not (조건1) or (조건2 and 조건3) or not 조건4:
      # 이게 뭔 경우인지 헷갈림

  # ✅ 단순한 접근
  if 범위_밖:
      continue
  if 이미_방문:
      continue
  if 갈수없음:
      continue
  # 명확함!
  ```
- **좋은 습관**:
  1. 조건문은 긍정형으로
  2. 한 번에 하나씩 체크
  3. 변수 이름 명확하게
  4. 함수 분리해서 단순하게

### 3. **Python에서 DFS vs BFS**
- **DFS (재귀)**:
  - 장점: 코드 짧고 직관적
  - 단점: 재귀 깊이 제한, 스택 오버플로우 위험, Python에서 느림
  - 필수: `sys.setrecursionlimit()` 설정

- **BFS (큐)**:
  - 장점: 재귀 깊이 걱정 없음, 메모리 안정적, Python에서 더 빠름
  - 단점: `deque` import 필요, 코드 약간 김
  - 추천: **Python에서는 BFS 추천!**

- **선택 기준**:
  - 그리드 크기 작음 (N<50) → DFS도 괜찮음
  - 그리드 크기 큼 (N≥100) → BFS 추천
  - 최단 거리 문제 → BFS 필수

## 배운 점

### 1. **Python 정렬 문법**
```python
# lambda는 key 파라미터로 사용
arr.sort(key=lambda x: x[1])  # ✅ 끝나는 시간 기준

# 옛날 방식 (Python 2) - 지원 안함
arr.sort(lambda a, b: b)  # ❌

# 여러 조건 정렬 (튜플 반환)
arr.sort(key=lambda x: (x[1], x[0]))
```

### 2. **범위 체크 시 주의점**
```python
# ❌ 잘못된 방법 - or 연산자는 뒤도 실행함!
if not (0<=nx<m and 0<=ny<n) or arr[ny][nx] != -1:
    # 범위 밖인데 arr[ny][nx] 접근 → IndexError

# ✅ 올바른 방법 - 범위 체크 먼저 분리
if not (0<=nx<m and 0<=ny<n):
    continue
if arr[ny][nx] != -1:
    continue
```

### 3. **변수 대입 실수**
```python
# ❌ 2차원 배열을 숫자로 덮어씀
result_mtx = lev  # TypeError: 'int' object is not subscriptable

# ✅ 인덱스 사용
result_mtx[ny][nx] = lev
```

### 4. **백트래킹 vs 그리디**
- 백트래킹: O(2^N) - 완전 탐색, 정확하지만 느림
- 그리디: O(N log N) - 정렬 후 탐욕 선택, 빠르고 효율적
- 최적화 문제에서 정렬 가능하면 → 그리디 시도!

## 오늘의 실수 & 교훈

1. **`lambda` 사용법 혼동**
   - `sort(lambda a, b: ...)` ❌
   - `sort(key=lambda x: ...)` ✅

2. **범위 체크와 조건 결합**
   - `or` 연산자는 short-circuit이지만 뒤 조건도 평가될 수 있음
   - 범위 체크는 반드시 먼저, 분리해서!

3. **변수 이름 혼동으로 인한 대입 실수**
   - `result_mtx = lev` vs `result_mtx[i][j] = lev`
   - 2차원 배열은 항상 인덱스 2개!

4. **접근 방법 선택 실수**
   - 회의실 배정을 백트래킹으로 → 시간 초과
   - 범위/구간 문제는 정렬 먼저 생각!

## 다음 목표

- [ ] 그리디 알고리즘 문제 더 풀어보기
- [ ] BFS/DFS 혼합 문제 연습
- [ ] 정렬 기준 설정 연습 (람다 함수)
- [ ] 이분 탐색 연습 계속
