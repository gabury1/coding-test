# 2025-12-28 코딩테스트 문제 풀이

## 해결한 문제

### [1931] 회의실 배정 ✅
- **알고리즘**: 그리디 (Greedy) + 정렬
- **핵심 개념**:
  - 끝나는 시간 기준으로 정렬 후 탐욕적 선택
  - 끝나는 시간이 같으면 시작 시간 기준 정렬
  - 이전 회의 끝나는 시간만 기억하면 됨
- **구현 포인트**:
  - `arr.sort(key=lambda x: (x[1], x[0]))` - 끝나는 시간 우선, 같으면 시작 시간
  - `pre_end <= start` - 끝나는 시간 = 다음 시작 시간 허용 (`<=` 사용)
  - 마지막 회의의 끝나는 시간만 추적하면 충분
- **시행착오**:
  - ❌ 처음에 백트래킹(DFS)으로 접근 → O(2^N) 시간 복잡도
  - ✅ 정렬 + 그리디로 변경 → O(N log N)
  - ❌ `sort(lambda a, b: b)` - lambda 사용법 오류
  - ✅ `sort(key=lambda x: x[1])` - key 파라미터로 정렬 기준 지정

### [10026] 적록색약 ✅
- **알고리즘**: DFS (깊이 우선 탐색)
- **핵심 개념**:
  - 일반인과 적록색약 두 경우를 동시에 처리
  - 파란색(B)는 두 경우 모두 동일하게 구분
  - 빨강(R)과 초록(G)은 적록색약에게 같은 색
- **구현 포인트**:
  - `sys.setrecursionlimit()` 설정 필요 (N=100이면 10000 정도면 충분)
  - 일반인용 DFS + 적록색약용 DFS 분리
  - B는 한 번만 카운트, R/G는 각각 처리
- **개선점**:
  - BFS로 구현하면 재귀 깊이 걱정 없음
  - 그리드를 2개 만들어 분리하면 더 명확함
  ```python
  special_grid = [row.replace('G', 'R') for row in grid]
  ```

### [14940] 쉬운 최단거리 ✅
- **알고리즘**: BFS (너비 우선 탐색)
- **핵심 개념**:
  - 목표 지점(2)에서 시작하여 모든 칸까지의 최단 거리 계산
  - 갈 수 없는 곳(0)은 0으로, 도달 불가능한 곳은 -1로 표시
- **구현 포인트**:
  - 시작점(2)을 큐에 넣고 거리 0으로 초기화
  - 방문 체크 배열로 중복 방문 방지
  - 원래 0인 곳은 결과도 0으로 설정
- **버그 & 해결**:
  - ❌ `if not (범위체크) and 조건` → 범위 밖인데 배열 접근
  - ✅ `if not (범위체크): continue` → 범위 체크 먼저 분리
  - ❌ `result_mtx = lev` → 전체 행렬을 숫자로 덮어씀
  - ✅ `result_mtx[ny][nx] = lev + 1` → 인덱스 추가
  - ❌ `or` 연산자로 범위 체크와 다른 조건 결합
  - ✅ 범위 체크를 먼저 하고, 범위 안일 때만 다음 조건 체크

## 새로운 인사이트

### 1. **범위/구간 문제는 정렬부터!** ⭐
- "범위", "구간", "시간" 키워드가 나오면 → **정렬부터 시도**
- 정렬 후 그리디 알고리즘이 대부분 통함
- **왜 효과적인가?**
  - 국소적 최적 선택 = 전역 최적해
  - 명확한 선택 기준 생성
  - O(N log N) 정렬 + O(N) 탐색 = 효율적
- **대표 문제 유형**:
  - 회의실 배정, ATM 대기 시간, 로프, 선 긋기, 과제 마감일 등
- **정렬 팁**:
  ```python
  # 끝나는 시간 우선, 같으면 시작 시간
  arr.sort(key=lambda x: (x[1], x[0]))

  # 첫번째 오름차순, 두번째 내림차순
  arr.sort(key=lambda x: (x[0], -x[1]))
  ```
- 📝 상세 내용은 [`insight/범위와 구간 문제는 정렬부터.md`](../insight/범위와%20구간%20문제는%20정렬부터.md) 참고

### 2. **어려운 문제일수록 로직을 단순하게!**
- 복잡한 로직 = 디버깅 지옥 + 엣지 케이스 폭증
- 단순한 로직 = 버그 적음 + 실수 감소 + 빠른 구현
- **실전 전략**:
  ```python
  # ❌ 복잡한 접근
  if not (조건1) or (조건2 and 조건3) or not 조건4:
      # 이게 뭔 경우인지 헷갈림

  # ✅ 단순한 접근
  if 범위_밖:
      continue
  if 이미_방문:
      continue
  if 갈수없음:
      continue
  # 명확함!
  ```
- **좋은 습관**:
  1. 조건문은 긍정형으로
  2. 한 번에 하나씩 체크
  3. 변수 이름 명확하게
  4. 함수 분리해서 단순하게

### 3. **Python에서 DFS vs BFS**
- **DFS (재귀)**:
  - 장점: 코드 짧고 직관적
  - 단점: 재귀 깊이 제한, 스택 오버플로우 위험, Python에서 느림
  - 필수: `sys.setrecursionlimit()` 설정

- **BFS (큐)**:
  - 장점: 재귀 깊이 걱정 없음, 메모리 안정적, Python에서 더 빠름
  - 단점: `deque` import 필요, 코드 약간 김
  - 추천: **Python에서는 BFS 추천!**

- **선택 기준**:
  - 그리드 크기 작음 (N<50) → DFS도 괜찮음
  - 그리드 크기 큼 (N≥100) → BFS 추천
  - 최단 거리 문제 → BFS 필수

## 배운 점

### 1. **Python 정렬 문법**
```python
# lambda는 key 파라미터로 사용
arr.sort(key=lambda x: x[1])  # ✅ 끝나는 시간 기준

# 옛날 방식 (Python 2) - 지원 안함
arr.sort(lambda a, b: b)  # ❌

# 여러 조건 정렬 (튜플 반환)
arr.sort(key=lambda x: (x[1], x[0]))
```

### 2. **범위 체크 시 주의점**
```python
# ❌ 잘못된 방법 - or 연산자는 뒤도 실행함!
if not (0<=nx<m and 0<=ny<n) or arr[ny][nx] != -1:
    # 범위 밖인데 arr[ny][nx] 접근 → IndexError

# ✅ 올바른 방법 - 범위 체크 먼저 분리
if not (0<=nx<m and 0<=ny<n):
    continue
if arr[ny][nx] != -1:
    continue
```

### 3. **변수 대입 실수**
```python
# ❌ 2차원 배열을 숫자로 덮어씀
result_mtx = lev  # TypeError: 'int' object is not subscriptable

# ✅ 인덱스 사용
result_mtx[ny][nx] = lev
```

### 4. **백트래킹 vs 그리디**
- 백트래킹: O(2^N) - 완전 탐색, 정확하지만 느림
- 그리디: O(N log N) - 정렬 후 탐욕 선택, 빠르고 효율적
- 최적화 문제에서 정렬 가능하면 → 그리디 시도!

## 오늘의 실수 & 교훈

1. **`lambda` 사용법 혼동**
   - `sort(lambda a, b: ...)` ❌
   - `sort(key=lambda x: ...)` ✅

2. **범위 체크와 조건 결합**
   - `or` 연산자는 short-circuit이지만 뒤 조건도 평가될 수 있음
   - 범위 체크는 반드시 먼저, 분리해서!

3. **변수 이름 혼동으로 인한 대입 실수**
   - `result_mtx = lev` vs `result_mtx[i][j] = lev`
   - 2차원 배열은 항상 인덱스 2개!

4. **접근 방법 선택 실수**
   - 회의실 배정을 백트래킹으로 → 시간 초과
   - 범위/구간 문제는 정렬 먼저 생각!

### [1916] 최소 비용 구하기 ✅
- **알고리즘**: 다익스트라 (Dijkstra)
- **핵심 개념**:
  - 하나의 시작점에서 다른 모든 정점까지의 최단 경로
  - 우선순위 큐(heapq) 사용
  - 양의 가중치만 가능
- **구현 포인트**:
  - `import heapq` - 최소 힙 사용
  - `heap.heappush(heap, (거리, 노드))` - 거리가 작은 것부터
  - `if cur_dist > dist[cur_node]: continue` - 중복 처리 방지 (핵심!)
  - 인접 리스트 사용 - 메모리 효율적
- **시행착오**:
  - ❌ DFS로 시도 → O(V!) 시간 복잡도
  - ❌ 인접 행렬 사용 → 메모리 초과 (N×N 배열)
  - ✅ 인접 리스트로 변경 → 메모리 절약
  - ❌ 중복 처리 방지 없음 → 시간/메모리 초과
  - ✅ `if dist > sp_arr[city]: continue` 추가 → 해결
- **배운 점**:
  - 다익스트라 = BFS + 우선순위 큐
  - 가중치가 다르면 일반 BFS 불가
  - 중복 처리 방지가 핵심 최적화

### [2096] 내려가기 (진행중)
- **알고리즘**: DP (동적 계획법)
- **문제점 발견**:
  - ❌ 백트래킹으로 시도 → O(3^N) 메모리 초과
  - ✅ DP로 접근 필요
- **DP 이해**:
  - 최적 부분 구조: 큰 문제의 최적해 = 작은 문제의 최적해 조합
  - 중복 부분 문제: 같은 계산을 여러 번 반복
  - **핵심**: 모든 상태의 최적값 저장 → 다음에서 선택 가능

## 새로운 알고리즘 학습

### 4. **다익스트라 (Dijkstra)** ⭐
- **언제 사용?**
  - 가중치가 있는 최단 경로 문제
  - 양의 가중치만 (음수 불가)

- **핵심 구조**:
  ```python
  import heapq

  dist = [float('inf')] * (N+1)
  dist[start] = 0
  heap = [(0, start)]

  while heap:
      cur_dist, cur_node = heapq.heappop(heap)

      # 중복 처리 방지 (핵심!)
      if cur_dist > dist[cur_node]:
          continue

      for next_node, weight in graph[cur_node]:
          new_dist = cur_dist + weight
          if new_dist < dist[next_node]:
              dist[next_node] = new_dist
              heapq.heappush(heap, (new_dist, next_node))
  ```

- **주의사항**:
  - 인접 리스트 사용 (인접 행렬 ❌ 메모리 초과)
  - 중복 처리 방지 필수
  - `(거리, 노드)` 순서로 힙에 추가
  - `float('inf')`로 초기화

### 5. **DP (동적 계획법) 개념 이해** ⭐⭐
- **DP의 본질**:
  - "모든 상태의 최적값"을 저장
  - 다음 단계에서 필요한 것을 "선택"
  - 그리디와의 차이: 하나만 vs 모든 것

- **DP 조건**:
  1. **최적 부분 구조** (필수!) - 큰 문제의 최적해 = 작은 문제의 최적해 조합
  2. **중복 부분 문제** - 같은 계산 반복

- **그리디 vs DP**:
  ```python
  # 그리디: 하나만 저장
  best = max(arr)  # 다음 선택 제한됨

  # DP: 모든 상태 저장
  dp[0] = 10  # 0번 위치 최적
  dp[1] = 5   # 1번 위치 최적
  dp[2] = 20  # 2번 위치 최적
  # 다음에서 최적 선택 가능!
  ```

### 6. **방문 체크 방법** (Python)
- **리스트** (가장 빠름!) ⭐
  ```python
  visited = [False] * (N+1)
  visited[node] = True
  ```
  - O(1) 접근, 메모리 효율적
  - 노드 번호가 1~N 범위일 때 최적

- **Set**
  ```python
  visited = set()
  visited.add(node)
  if node not in visited:
  ```
  - 노드 번호가 불규칙할 때
  - 동적으로 추가/제거 필요할 때

- **Dictionary**
  ```python
  visited = {}
  visited[node] = 거리  # 추가 정보 저장
  ```
  - 방문 여부 + 추가 정보 동시 저장

## 추가 배운 점

### 5. **heapq 사용법**
```python
import heapq

heap = []
heapq.heappush(heap, (5, 'A'))  # (우선순위, 값)
dist, node = heapq.heappop(heap)  # 최솟값 꺼내기

# 튜플 사용 - 첫 번째 요소로 정렬
heapq.heappush(heap, (거리, 노드))  # 거리가 작은 것부터
```

### 6. **인접 리스트 vs 인접 행렬**
```python
# ❌ 인접 행렬 - 메모리 낭비
graph = [[0]*(N+1) for _ in range(N+1)]  # N=1000이면 100만개

# ✅ 인접 리스트 - 효율적
graph = [[] for _ in range(N+1)]
graph[s].append((e, w))  # 실제 간선만 저장
```

### 7. **ValueError 해결**
```python
# min() 빈 리스트 에러
res = []
min(res)  # ValueError!

# 해결
return min(res) if res else float('inf')
```

### 8. **DP 판단 기준**
- 이전 선택이 영향? → 판단 불충분
- **이전 "최적값" 사용?** → DP 가능성 높음!
- 최적 부분 구조? → DP 핵심 조건!

## 오늘의 성장

### 알고리즘 패턴 6가지 정리
1. **DFS** - 깊이 우선 탐색
2. **BFS** - 너비 우선 탐색 (최단 거리)
3. **백트래킹** - 모든 경우의 수 + 가지치기
4. **그리디** - 정렬 + 탐욕적 선택
5. **다익스트라** - 가중치 있는 최단 경로
6. **DP** - 최적 부분 구조 + 메모이제이션

각 알고리즘별 상세 문서 작성:
- [`insight/DFS 깊이 우선 탐색.md`](../insight/DFS%20깊이%20우선%20탐색.md)
- [`insight/BFS 너비 우선 탐색.md`](../insight/BFS%20너비%20우선%20탐색.md)
- [`insight/백트래킹 Backtracking.md`](../insight/백트래킹%20Backtracking.md)
- [`insight/그리디 Greedy.md`](../insight/그리디%20Greedy.md)
- [`insight/다익스트라 Dijkstra.md`](../insight/다익스트라%20Dijkstra.md)
- [`insight/정렬 Sorting.md`](../insight/정렬%20Sorting.md)

## 오늘의 깨달음

> **"DP = 모든 최적을 저장 → 다음에서 선택"**

이게 DP의 본질이다. 그리디는 하나만 선택하지만, DP는 모든 가능성을 열어두고 나중에 최적을 선택한다.

## 다음 목표

- [ ] DP 문제 더 풀어보기 (Top-Down, Bottom-Up)
- [ ] 다익스트라 변형 문제 연습
- [ ] 최적 부분 구조 판단 연습
- [ ] 메모이제이션 패턴 익히기
