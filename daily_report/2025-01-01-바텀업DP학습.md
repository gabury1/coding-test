# 2025-01-01 학습 일지: 바텀업 DP 마스터하기

## 오늘의 주제
탑다운 DP를 바텀업 DP로 변환하는 방법 학습

---

## 핵심 개념 정리

### 1. DP(Dynamic Programming)의 정의
**"큰 문제를 작은 부분 문제로 나누고, 각 부분 문제의 답을 저장해서 재사용하는 알고리즘 기법"**

**필수 조건 2가지:**
1. **최적 부분 구조**: 큰 문제의 최적해가 작은 문제들의 최적해로 구성됨
2. **중복되는 부분 문제**: 같은 작은 문제가 여러 번 반복됨

### 2. 탑다운 vs 바텀업

| 구분 | 탑다운 (Top-down) | 바텀업 (Bottom-up) |
|------|-------------------|-------------------|
| 구현 방식 | **재귀** + 메모이제이션 | **반복문** |
| 사고 방식 | 큰 문제 → 작은 문제 | 작은 문제 → 큰 문제 |
| 계산 방식 | 필요한 것만 계산 (lazy) | 모든 상태 계산 (eager) |
| 속도 | 재귀 오버헤드 있음 | 약간 더 빠름 (1.2~1.5배) |
| 난이도 | **직관적이고 쉬움** | 의존성 파악이 어려움 |

**중요:** 실전에서는 속도 차이보다 **코드 짜기 쉬운 게** 더 중요!

---

## 탑다운 → 바텀업 변환 7단계

### 1단계: DP 상태 정의 확인
```python
dp(i, j) = (i, j)에서 목표까지 가는 경우의 수
```

### 2단계: 재귀 호출 방향 파악
- 탑다운: (0,0) → (0,1) → ... → (N-1, N-1)
- 바텀업: **반대로!** (N-1, N-1) → ... → (0,0)

### 3단계: 베이스 케이스 찾기
- 재귀의 종료 조건 = 바텀업의 초기값
- 예: 목표 도달 시 `return 1` → `memo[goal] = 1`

### 4단계: 점화식 찾기
```python
# 탑다운
dp(i, j) = dp(i-1, j) + dp(i, j-1)

# 바텀업 (똑같음!)
memo[i][j] = memo[i-1][j] + memo[i][j-1]
```

### 5단계: 반복문 순서 정하기
**핵심:** 의존성 분석!
```python
# memo[i][j]가 memo[i-1][j], memo[i][j-1]을 사용
# → i-1, j-1이 먼저 계산되어야 함
# → 작은 값부터 큰 값으로!

for i in range(N):
    for j in range(N):
        # ...
```

**거꾸로 가는 경우:**
```python
# memo[r][c]가 memo[r+1][c+1]을 사용
# → r+1, c+1이 먼저 계산되어야 함
# → 큰 값부터 작은 값으로!

for r in range(N-1, -1, -1):  # N-1부터 0까지
    for c in range(N-1, -1, -1):
        # ...
```

### 6단계: 벽/예외 처리
```python
# 초기값이 0이면, 벽은 그냥 continue로 넘김
for i in range(N):
    if (벽이면):
        continue  # 0 유지
    # 점화식
```

### 7단계: 최종 답 출력
```python
print(memo[0][0])  # 시작점의 값
```

---

## 오늘 푼 문제: [17070] 파이프 옮기기1

### 문제 핵심
- 3D DP: `memo[r][c][t]` (위치 + 파이프 방향)
- t = 0(가로), 1(대각선), 2(세로)

### 탑다운 점화식
```python
if t == 0:  # 가로
    dp(r, c, 0) = dp(r, c+1, 0) + dp(r, c+1, 1)
if t == 1:  # 대각선
    dp(r, c, 1) = dp(r+1, c+1, 0) + dp(r+1, c+1, 1) + dp(r+1, c+1, 2)
if t == 2:  # 세로
    dp(r, c, 2) = dp(r+1, c, 1) + dp(r+1, c, 2)
```

### 바텀업 구조
```python
memo = [[[0]*3 for _ in range(N)] for _ in range(N)]

# 거꾸로 순회 (큰 값 → 작은 값)
for r in range(N-1, -1, -1):
    for c in range(N-1, -1, -1):
        for t in range(3):
            # 1. 벽 체크 → continue
            # 2. 베이스 케이스 (목표 도달) → memo = 1
            # 3. 점화식 적용

print(memo[0][0][0])
```

---

## 헷갈렸던 부분 & 해결

### Q1: 바텀업은 0부터 올라가는 거 아냐?
**A:** 아니요! "바텀업"은 **작은 문제부터** 푸는 거예요.
- 의존성에 따라 순서가 달라짐
- `memo[i][j]`가 `memo[i+1][j+1]`을 쓰면 → **거꾸로** 가야 함!

### Q2: `range(N-1, -1, -1)`에서 -1까지 가는 거야?
**A:** `-1`은 **stop 값**(미포함)이에요!
```python
range(N-1, -1, -1)  # N-1, N-2, ..., 1, 0 (0 포함!)
range(N-1, 0, -1)   # N-1, N-2, ..., 2, 1 (0 제외!)
```

### Q3: 벽을 0으로 표시해야 하나?
**A:** 배열 초기값이 이미 0이니까, 벽은 **손 안 대고** `continue`로 넘기면 돼요!
```python
memo = [[[0]*3 ...]]  # 이미 전부 0

for r, c, t:
    if (벽):
        continue  # 0 유지
    # 점화식
```

### Q4: 바텀업이 탑다운보다 빠르겠지?
**A:** 이론상 약간 빠르지만 (1.2~1.5배), 차이 미미해요!
- 재귀 오버헤드가 없어서 빠름
- 하지만 **코딩 편의성**이 더 중요!
- 탑다운이 더 직관적이면 탑다운 선택!

---

## 오늘의 깨달음

1. **바텀업 = 탑다운 점화식을 반복문으로 번역한 것**
   - 점화식 자체는 똑같음!
   - 순서만 거꾸로!

2. **의존성 파악이 핵심**
   - `memo[i][j]`가 뭘 참조하는지 확인
   - 참조하는 게 먼저 계산되게 반복문 순서 정하기

3. **탑다운이 더 쉬울 수도 있다**
   - 바텀업은 연습용/최적화용
   - 실전에선 탑다운으로 푸는 게 나을 때 많음

4. **"너는 1타 강사야" ㅋㅋㅋ**

---

## 다음 학습 계획

- [ ] 바텀업 DP 코드 직접 완성해보기
- [ ] [17070] 파이프 옮기기1 제출하고 맞추기
- [ ] 다른 DP 문제도 탑다운 → 바텀업 변환 연습
- [ ] 슬라이딩 윈도우 최적화 공부

---

## 함께한 문제들

- [2096] 내려가기 - 슬라이딩 윈도우 DP
- [1149] RGB거리 - 기본 DP
- [9251] LCS - 유명 알고리즘 (외워야 함!)
- [13549] 숨바꼭질3 - 다익스트라
- [17070] 파이프 옮기기1 - 3D DP (진행 중)

---

**오늘도 고생했어! 킵고잉!!! 💪**
